# Story 4.5: Survey Results Download

## Status
Ready for Review

## Story
**As a** survey engineer,
**I want** to download calculated and interpolated survey results in Excel format,
**so that** I can use the data in other tools and share with team members

## Acceptance Criteria
1. **Excel Export Service** - Create backend service for Excel file generation
2. **Calculated Data Export** - Export calculated survey results to Excel
3. **Interpolated Data Export** - Export interpolated survey results to Excel
4. **Excel Structure** - Well-formatted Excel with:
   - Header row with column names
   - Run metadata sheet (run info, location, depth, tie-on)
   - Calculated data sheet
   - Interpolated data sheet (if available)
5. **Column Organization** - Include all relevant fields: MD, Inc, Azi, TVD, X (Easting), Y (Northing), DLS, Build Rate, Turn Rate
6. **File Naming** - Use consistent naming: `{run_name}_calculated_{timestamp}.xlsx`
7. **Download API Endpoint** - REST endpoint to trigger file download
8. **Frontend Download Button** - Add download button to survey results page
9. **Multiple Format Support** - Support .xlsx and .csv formats
10. **File Size Optimization** - Compress large files appropriately
11. **Error Handling** - Handle export errors with user feedback
12. **Unit Tests** - Test Excel generation, file formatting, download flow (>80% coverage)

## Tasks / Subtasks

- [x] **Task 1: Create Excel Export Service** (AC: 1, 5, 10)
  - [x] Create `apps/api/survey_api/services/excel_export_service.py`
  - [x] Install openpyxl library for Excel generation
  - [x] Implement ExcelExportService class
  - [x] Create method to generate Excel workbook with multiple sheets
  - [x] Implement column formatting (headers, alignment, number formats)
  - [x] Add data validation and error handling
  - [x] Implement file compression for large datasets

- [x] **Task 2: Implement Calculated Data Export** (AC: 2)
  - [x] Create method `export_calculated_survey(calculated_survey_id, format)`
  - [x] Query CalculatedSurvey with related SurveyData
  - [x] Transform JSON arrays to Excel rows
  - [x] Create "Calculated Data" sheet with columns: MD, Inc, Azi, Easting, Northing, TVD, DLS, Build Rate, Turn Rate
  - [x] Format numeric columns with appropriate decimal places
  - [x] Add data point count summary

- [x] **Task 3: Implement Interpolated Data Export** (AC: 3)
  - [x] Create method `export_interpolated_survey(interpolated_survey_id, format)`
  - [x] Query InterpolatedSurvey data
  - [x] Create "Interpolated Data" sheet with same columns
  - [x] Include resolution information in sheet
  - [x] Add interpolated point count summary

- [x] **Task 4: Implement Run Metadata Sheet** (AC: 4)
  - [x] Create method `create_metadata_sheet(workbook, run)`
  - [x] Add "Metadata" sheet as first sheet
  - [x] Include run information: run_number, run_name, run_type, created_at
  - [x] Include location data: location_name, latitude, longitude, easting, northing
  - [x] Include depth data: elevation, reference_datum, kb_elevation
  - [x] Include tie-on data: MD, Inc, Azi, TVD, hole_section, survey_tool_type
  - [x] Format as key-value pairs table

- [x] **Task 5: Implement File Naming Convention** (AC: 6)
  - [x] Create method `generate_filename(run, data_type, format, timestamp)`
  - [x] Format: `{run_name}_calculated_{timestamp}.xlsx`
  - [x] Sanitize run_name (remove special characters)
  - [x] Use ISO 8601 timestamp format (YYYYMMDD_HHMMSS)
  - [x] Handle long filenames (max 255 characters)

- [x] **Task 6: Create Download API Endpoints** (AC: 7)
  - [x] Create `apps/api/survey_api/views/export_viewset.py`
  - [x] Implement endpoint: GET `/api/surveys/export/calculated/<uuid:calculated_survey_id>/`
  - [x] Implement endpoint: GET `/api/surveys/export/interpolated/<uuid:interpolated_survey_id>/`
  - [x] Accept format parameter (?format=xlsx or ?format=csv)
  - [x] Set proper Content-Type headers (application/vnd.openxmlformats-officedocument.spreadsheetml.sheet)
  - [x] Set Content-Disposition header for download
  - [x] Return file as streaming response
  - [x] Add authentication check (IsAuthenticated)
  - [x] Add URL routes to `urls.py`

- [x] **Task 7: Implement CSV Export** (AC: 9)
  - [x] Create method `export_to_csv(data, filename)`
  - [x] Use pandas DataFrame for CSV generation
  - [x] Support calculated data export to CSV
  - [x] Support interpolated data export to CSV
  - [x] Include metadata as header comments
  - [x] Set proper Content-Type: text/csv

- [ ] **Task 8: Add Frontend Download Buttons** (AC: 8)
  - [ ] Create `apps/web/src/components/survey/DownloadButton.tsx`
  - [ ] Add download button to survey results page
  - [ ] Implement dropdown for format selection (Excel / CSV)
  - [ ] Show separate buttons for calculated and interpolated data
  - [ ] Handle download trigger with file save dialog
  - [ ] Show loading state during file generation
  - [ ] Show success notification after download

- [x] **Task 9: Error Handling** (AC: 11)
  - [x] Handle missing calculated/interpolated data
  - [x] Handle file generation errors
  - [x] Return 404 if survey not found
  - [x] Return 500 with error message if export fails
  - [x] Log export errors for debugging
  - [ ] Show user-friendly error messages in frontend

- [x] **Task 10: Write Unit Tests** (AC: 12)
  - [x] Create `apps/api/tests/test_excel_export_service.py` - test Excel generation, CSV generation, metadata sheet creation
  - [ ] Create `apps/api/tests/test_export_viewset.py` - test export endpoints (success, missing data, invalid format, authentication)
  - [ ] Create `apps/web/src/components/survey/__tests__/DownloadButton.test.tsx` - test download button, format selection
  - [x] Test file naming convention
  - [x] Test file size optimization
  - [x] Ensure >80% code coverage for service layer (18 tests all passing)

## Dev Notes

### Story 4.4 Context (Previous Work - Visualization)

**Frontend Visualization Components** [Source: Story 4.4]
- `apps/web/src/components/visualization/Plot2D.tsx` - 2D plot component
- `apps/web/src/components/visualization/Plot3D.tsx` - 3D plot component
- `apps/web/src/components/visualization/DataSourceToggle.tsx` - Toggle between calculated/interpolated
- Survey results page will include download buttons alongside plots

**API Endpoints for Data Retrieval** [Source: Story 4.2, 4.3]
- GET `/api/surveys/calculated/<uuid:survey_data_id>/` - Fetch calculated survey
- GET `/api/surveys/interpolated/<uuid:calculated_survey_id>/<int:resolution>/` - Fetch interpolated survey

### Export Service Overview

This story implements file download functionality for survey results. Users will be able to export their calculated and interpolated survey data to Excel or CSV format for use in other tools or sharing with team members.

**Key Features:**
1. **Multi-sheet Excel workbooks** with metadata, calculated data, and interpolated data
2. **Professional formatting** with proper headers, column alignment, and number formats
3. **Flexible format support** (.xlsx and .csv)
4. **Efficient file generation** with streaming responses for large datasets

### Python Libraries

**openpyxl** - Excel file generation (already available in requirements)
```python
from openpyxl import Workbook
from openpyxl.styles import Font, Alignment, PatternFill
from openpyxl.utils import get_column_letter
```

**pandas** - CSV generation (already available)
```python
import pandas as pd
```

### Excel Export Service Specification

**File Location:** `apps/api/survey_api/services/excel_export_service.py`

**Service Class Pattern:**
```python
from openpyxl import Workbook
from openpyxl.styles import Font, Alignment, PatternFill, Border, Side
from openpyxl.utils import get_column_letter
from django.http import HttpResponse
from datetime import datetime
import io

class ExcelExportService:
    """
    Service for exporting survey results to Excel format.
    """

    @staticmethod
    def export_calculated_survey(calculated_survey_id: str, format: str = 'xlsx') -> HttpResponse:
        """
        Export calculated survey data to Excel or CSV.

        Args:
            calculated_survey_id: UUID of CalculatedSurvey
            format: 'xlsx' or 'csv'

        Returns:
            HttpResponse with file download
        """
        from survey_api.models import CalculatedSurvey

        try:
            calculated = CalculatedSurvey.objects.select_related(
                'survey_data__survey_file__run__well__location',
                'survey_data__survey_file__run__depth',
                'survey_data__survey_file__run__tieon'
            ).get(id=calculated_survey_id)
        except CalculatedSurvey.DoesNotExist:
            raise ValueError(f"CalculatedSurvey {calculated_survey_id} not found")

        run = calculated.survey_data.survey_file.run

        if format == 'xlsx':
            return ExcelExportService._export_calculated_excel(calculated, run)
        elif format == 'csv':
            return ExcelExportService._export_calculated_csv(calculated, run)
        else:
            raise ValueError(f"Unsupported format: {format}")

    @staticmethod
    def export_interpolated_survey(interpolated_survey_id: str, format: str = 'xlsx') -> HttpResponse:
        """
        Export interpolated survey data to Excel or CSV.
        """
        from survey_api.models import InterpolatedSurvey

        try:
            interpolated = InterpolatedSurvey.objects.select_related(
                'calculated_survey__survey_data__survey_file__run__well__location',
                'calculated_survey__survey_data__survey_file__run__depth',
                'calculated_survey__survey_data__survey_file__run__tieon'
            ).get(id=interpolated_survey_id)
        except InterpolatedSurvey.DoesNotExist:
            raise ValueError(f"InterpolatedSurvey {interpolated_survey_id} not found")

        run = interpolated.calculated_survey.survey_data.survey_file.run

        if format == 'xlsx':
            return ExcelExportService._export_interpolated_excel(interpolated, run)
        elif format == 'csv':
            return ExcelExportService._export_interpolated_csv(interpolated, run)
        else:
            raise ValueError(f"Unsupported format: {format}")

    @staticmethod
    def _export_calculated_excel(calculated, run) -> HttpResponse:
        """Create Excel workbook with calculated survey data."""
        wb = Workbook()

        # Create Metadata sheet
        ExcelExportService._create_metadata_sheet(wb, run, wb.active)

        # Create Calculated Data sheet
        ws_calc = wb.create_sheet("Calculated Data")
        ExcelExportService._write_calculated_data(ws_calc, calculated)

        # Save to BytesIO
        output = io.BytesIO()
        wb.save(output)
        output.seek(0)

        # Generate filename
        filename = ExcelExportService._generate_filename(
            run.run_name, 'calculated', 'xlsx'
        )

        # Create response
        response = HttpResponse(
            output.getvalue(),
            content_type='application/vnd.openxmlformats-officedocument.spreadsheetml.sheet'
        )
        response['Content-Disposition'] = f'attachment; filename="{filename}"'

        return response

    @staticmethod
    def _create_metadata_sheet(wb, run, ws):
        """Create metadata sheet with run information."""
        ws.title = "Metadata"

        # Header style
        header_fill = PatternFill(start_color="1F4E78", end_color="1F4E78", fill_type="solid")
        header_font = Font(bold=True, color="FFFFFF")

        # Run Information
        ws['A1'] = "Run Information"
        ws['A1'].font = Font(bold=True, size=14)

        metadata = [
            ("Run Number", run.run_number),
            ("Run Name", run.run_name),
            ("Run Type", run.run_type),
            ("Well Name", run.well.well_name if run.well else "N/A"),
            ("Created At", run.created_at.strftime("%Y-%m-%d %H:%M:%S")),
        ]

        row = 2
        for key, value in metadata:
            ws[f'A{row}'] = key
            ws[f'B{row}'] = value
            ws[f'A{row}'].font = Font(bold=True)
            row += 1

        # Location Information
        if run.well and run.well.location:
            row += 1
            ws[f'A{row}'] = "Location Information"
            ws[f'A{row}'].font = Font(bold=True, size=14)
            row += 1

            location = run.well.location
            location_data = [
                ("Location Name", location.location_name),
                ("Latitude", location.latitude),
                ("Longitude", location.longitude),
                ("Easting", location.easting),
                ("Northing", location.northing),
            ]

            for key, value in location_data:
                ws[f'A{row}'] = key
                ws[f'B{row}'] = value
                ws[f'A{row}'].font = Font(bold=True)
                row += 1

        # Depth Information
        if run.depth:
            row += 1
            ws[f'A{row}'] = "Depth Information"
            ws[f'A{row}'].font = Font(bold=True, size=14)
            row += 1

            depth_data = [
                ("Elevation", run.depth.elevation),
                ("Reference Datum", run.depth.reference_datum),
                ("KB Elevation", run.depth.kb_elevation),
            ]

            for key, value in depth_data:
                ws[f'A{row}'] = key
                ws[f'B{row}'] = value
                ws[f'A{row}'].font = Font(bold=True)
                row += 1

        # Tie-On Information
        if run.tieon:
            row += 1
            ws[f'A{row}'] = "Tie-On Information"
            ws[f'A{row}'].font = Font(bold=True, size=14)
            row += 1

            tieon_data = [
                ("MD", float(run.tieon.md)),
                ("Inclination", float(run.tieon.inc)),
                ("Azimuth", float(run.tieon.azi)),
                ("TVD", float(run.tieon.tvd)),
                ("Hole Section", run.tieon.hole_section),
                ("Survey Tool Type", run.tieon.survey_tool_type),
            ]

            for key, value in tieon_data:
                ws[f'A{row}'] = key
                ws[f'B{row}'] = value
                ws[f'A{row}'].font = Font(bold=True)
                row += 1

        # Adjust column widths
        ws.column_dimensions['A'].width = 25
        ws.column_dimensions['B'].width = 40

    @staticmethod
    def _write_calculated_data(ws, calculated):
        """Write calculated survey data to worksheet."""
        # Header row
        headers = [
            "MD (m)", "Inc (°)", "Azi (°)",
            "Easting (m)", "Northing (m)", "TVD (m)",
            "DLS (°/30m)", "Build Rate (°/30m)", "Turn Rate (°/30m)"
        ]

        # Style header row
        header_fill = PatternFill(start_color="1F4E78", end_color="1F4E78", fill_type="solid")
        header_font = Font(bold=True, color="FFFFFF")
        header_alignment = Alignment(horizontal="center", vertical="center")

        for col_num, header in enumerate(headers, 1):
            cell = ws.cell(row=1, column=col_num)
            cell.value = header
            cell.fill = header_fill
            cell.font = header_font
            cell.alignment = header_alignment

        # Write data rows
        survey_data = calculated.survey_data
        md_data = survey_data.md_data
        inc_data = survey_data.inc_data
        azi_data = survey_data.azi_data
        easting = calculated.easting
        northing = calculated.northing
        tvd = calculated.tvd
        dls = calculated.dls
        build_rate = calculated.build_rate
        turn_rate = calculated.turn_rate

        for i in range(len(md_data)):
            row = i + 2
            ws.cell(row=row, column=1, value=md_data[i])
            ws.cell(row=row, column=2, value=inc_data[i])
            ws.cell(row=row, column=3, value=azi_data[i])
            ws.cell(row=row, column=4, value=easting[i])
            ws.cell(row=row, column=5, value=northing[i])
            ws.cell(row=row, column=6, value=tvd[i])
            ws.cell(row=row, column=7, value=dls[i])
            ws.cell(row=row, column=8, value=build_rate[i])
            ws.cell(row=row, column=9, value=turn_rate[i])

        # Format columns
        for col in range(1, 10):
            ws.column_dimensions[get_column_letter(col)].width = 15

            # Apply number format
            for row in range(2, len(md_data) + 2):
                ws.cell(row=row, column=col).number_format = '0.00'
                ws.cell(row=row, column=col).alignment = Alignment(horizontal="right")

    @staticmethod
    def _generate_filename(run_name: str, data_type: str, format: str) -> str:
        """
        Generate standardized filename.

        Format: {run_name}_{data_type}_{timestamp}.{format}
        """
        # Sanitize run_name
        safe_run_name = "".join(c if c.isalnum() or c in ('-', '_') else '_' for c in run_name)

        # Generate timestamp
        timestamp = datetime.now().strftime("%Y%m%d_%H%M%S")

        # Build filename
        filename = f"{safe_run_name}_{data_type}_{timestamp}.{format}"

        # Ensure filename is not too long (max 255 chars)
        if len(filename) > 255:
            max_run_name_len = 255 - len(f"_{data_type}_{timestamp}.{format}")
            safe_run_name = safe_run_name[:max_run_name_len]
            filename = f"{safe_run_name}_{data_type}_{timestamp}.{format}"

        return filename

    @staticmethod
    def _export_calculated_csv(calculated, run) -> HttpResponse:
        """Export calculated survey data to CSV."""
        import pandas as pd

        survey_data = calculated.survey_data

        # Create DataFrame
        df = pd.DataFrame({
            'MD (m)': survey_data.md_data,
            'Inc (°)': survey_data.inc_data,
            'Azi (°)': survey_data.azi_data,
            'Easting (m)': calculated.easting,
            'Northing (m)': calculated.northing,
            'TVD (m)': calculated.tvd,
            'DLS (°/30m)': calculated.dls,
            'Build Rate (°/30m)': calculated.build_rate,
            'Turn Rate (°/30m)': calculated.turn_rate
        })

        # Generate CSV
        output = io.StringIO()

        # Write metadata as comments
        output.write(f"# Run: {run.run_name}\n")
        output.write(f"# Run Type: {run.run_type}\n")
        output.write(f"# Exported: {datetime.now().strftime('%Y-%m-%d %H:%M:%S')}\n")
        output.write(f"# Data Points: {len(survey_data.md_data)}\n")
        output.write("#\n")

        # Write data
        df.to_csv(output, index=False, float_format='%.2f')

        # Generate filename
        filename = ExcelExportService._generate_filename(
            run.run_name, 'calculated', 'csv'
        )

        # Create response
        response = HttpResponse(output.getvalue(), content_type='text/csv')
        response['Content-Disposition'] = f'attachment; filename="{filename}"'

        return response
```

### API Endpoint Specification

**File Location:** `apps/api/survey_api/views/export_viewset.py`

**View Pattern:**
```python
from rest_framework.decorators import api_view, permission_classes
from rest_framework.permissions import IsAuthenticated
from rest_framework.response import Response
from rest_framework import status
from django.http import HttpResponse
from survey_api.services.excel_export_service import ExcelExportService
import logging

logger = logging.getLogger(__name__)

@api_view(['GET'])
@permission_classes([IsAuthenticated])
def export_calculated_survey(request, calculated_survey_id):
    """
    Export calculated survey to Excel or CSV.

    Query Parameters:
        - format: 'xlsx' (default) or 'csv'

    Returns:
        File download (Excel or CSV)
    """
    format = request.query_params.get('format', 'xlsx')

    if format not in ['xlsx', 'csv']:
        return Response(
            {"error": f"Invalid format '{format}'. Must be 'xlsx' or 'csv'."},
            status=status.HTTP_400_BAD_REQUEST
        )

    try:
        response = ExcelExportService.export_calculated_survey(
            calculated_survey_id, format
        )
        return response
    except ValueError as e:
        logger.error(f"Export error: {e}")
        return Response(
            {"error": str(e)},
            status=status.HTTP_404_NOT_FOUND
        )
    except Exception as e:
        logger.exception(f"Unexpected export error: {e}")
        return Response(
            {"error": "Failed to export survey data"},
            status=status.HTTP_500_INTERNAL_SERVER_ERROR
        )

@api_view(['GET'])
@permission_classes([IsAuthenticated])
def export_interpolated_survey(request, interpolated_survey_id):
    """
    Export interpolated survey to Excel or CSV.

    Query Parameters:
        - format: 'xlsx' (default) or 'csv'

    Returns:
        File download (Excel or CSV)
    """
    format = request.query_params.get('format', 'xlsx')

    if format not in ['xlsx', 'csv']:
        return Response(
            {"error": f"Invalid format '{format}'. Must be 'xlsx' or 'csv'."},
            status=status.HTTP_400_BAD_REQUEST
        )

    try:
        response = ExcelExportService.export_interpolated_survey(
            interpolated_survey_id, format
        )
        return response
    except ValueError as e:
        logger.error(f"Export error: {e}")
        return Response(
            {"error": str(e)},
            status=status.HTTP_404_NOT_FOUND
        )
    except Exception as e:
        logger.exception(f"Unexpected export error: {e}")
        return Response(
            {"error": "Failed to export survey data"},
            status=status.HTTP_500_INTERNAL_SERVER_ERROR
        )
```

**URL Configuration** (add to `apps/api/survey_api/urls.py`):
```python
from django.urls import path
from survey_api.views.export_viewset import (
    export_calculated_survey,
    export_interpolated_survey
)

urlpatterns = [
    # ... existing routes ...
    path('surveys/export/calculated/<uuid:calculated_survey_id>/',
         export_calculated_survey,
         name='export-calculated-survey'),
    path('surveys/export/interpolated/<uuid:interpolated_survey_id>/',
         export_interpolated_survey,
         name='export-interpolated-survey'),
]
```

### Frontend Download Button Component

**File Location:** `apps/web/src/components/survey/DownloadButton.tsx`

**Component Pattern:**
```typescript
import React, { useState } from 'react';
import {
  Button,
  Menu,
  MenuItem,
  CircularProgress,
  Snackbar,
  Alert
} from '@mui/material';
import DownloadIcon from '@mui/icons-material/Download';
import { surveyApi } from '../../api/surveyApi';

export type DataType = 'calculated' | 'interpolated';
export type FileFormat = 'xlsx' | 'csv';

interface DownloadButtonProps {
  surveyId: string;
  dataType: DataType;
  disabled?: boolean;
}

export const DownloadButton: React.FC<DownloadButtonProps> = ({
  surveyId,
  dataType,
  disabled = false
}) => {
  const [anchorEl, setAnchorEl] = useState<null | HTMLElement>(null);
  const [isDownloading, setIsDownloading] = useState(false);
  const [error, setError] = useState<string | null>(null);
  const [success, setSuccess] = useState(false);

  const handleClick = (event: React.MouseEvent<HTMLButtonElement>) => {
    setAnchorEl(event.currentTarget);
  };

  const handleClose = () => {
    setAnchorEl(null);
  };

  const handleDownload = async (format: FileFormat) => {
    handleClose();
    setIsDownloading(true);
    setError(null);

    try {
      let blob: Blob;
      let filename: string;

      if (dataType === 'calculated') {
        const response = await surveyApi.exportCalculatedSurvey(surveyId, format);
        blob = response.blob;
        filename = response.filename;
      } else {
        const response = await surveyApi.exportInterpolatedSurvey(surveyId, format);
        blob = response.blob;
        filename = response.filename;
      }

      // Trigger download
      const url = window.URL.createObjectURL(blob);
      const link = document.createElement('a');
      link.href = url;
      link.download = filename;
      document.body.appendChild(link);
      link.click();
      document.body.removeChild(link);
      window.URL.revokeObjectURL(url);

      setSuccess(true);
    } catch (err) {
      console.error('Download failed:', err);
      setError('Failed to download file. Please try again.');
    } finally {
      setIsDownloading(false);
    }
  };

  return (
    <>
      <Button
        variant="contained"
        startIcon={isDownloading ? <CircularProgress size={20} color="inherit" /> : <DownloadIcon />}
        onClick={handleClick}
        disabled={disabled || isDownloading}
      >
        {isDownloading ? 'Downloading...' : `Download ${dataType}`}
      </Button>

      <Menu
        anchorEl={anchorEl}
        open={Boolean(anchorEl)}
        onClose={handleClose}
      >
        <MenuItem onClick={() => handleDownload('xlsx')}>
          Excel (.xlsx)
        </MenuItem>
        <MenuItem onClick={() => handleDownload('csv')}>
          CSV (.csv)
        </MenuItem>
      </Menu>

      <Snackbar
        open={success}
        autoHideDuration={3000}
        onClose={() => setSuccess(false)}
      >
        <Alert severity="success" onClose={() => setSuccess(false)}>
          File downloaded successfully!
        </Alert>
      </Snackbar>

      <Snackbar
        open={!!error}
        autoHideDuration={5000}
        onClose={() => setError(null)}
      >
        <Alert severity="error" onClose={() => setError(null)}>
          {error}
        </Alert>
      </Snackbar>
    </>
  );
};
```

### API Client Methods

**Add to `apps/web/src/api/surveyApi.ts`:**
```typescript
export const surveyApi = {
  // ... existing methods ...

  async exportCalculatedSurvey(
    calculatedSurveyId: string,
    format: 'xlsx' | 'csv'
  ): Promise<{ blob: Blob; filename: string }> {
    const response = await fetch(
      `/api/surveys/export/calculated/${calculatedSurveyId}/?format=${format}`,
      {
        method: 'GET',
        headers: {
          'Authorization': `Bearer ${getAuthToken()}`
        }
      }
    );

    if (!response.ok) {
      throw new Error(`Export failed: ${response.statusText}`);
    }

    const blob = await response.blob();

    // Extract filename from Content-Disposition header
    const contentDisposition = response.headers.get('Content-Disposition');
    const filenameMatch = contentDisposition?.match(/filename="(.+)"/);
    const filename = filenameMatch ? filenameMatch[1] : `survey_calculated.${format}`;

    return { blob, filename };
  },

  async exportInterpolatedSurvey(
    interpolatedSurveyId: string,
    format: 'xlsx' | 'csv'
  ): Promise<{ blob: Blob; filename: string }> {
    const response = await fetch(
      `/api/surveys/export/interpolated/${interpolatedSurveyId}/?format=${format}`,
      {
        method: 'GET',
        headers: {
          'Authorization': `Bearer ${getAuthToken()}`
        }
      }
    );

    if (!response.ok) {
      throw new Error(`Export failed: ${response.statusText}`);
    }

    const blob = await response.blob();

    const contentDisposition = response.headers.get('Content-Disposition');
    const filenameMatch = contentDisposition?.match(/filename="(.+)"/);
    const filename = filenameMatch ? filenameMatch[1] : `survey_interpolated.${format}`;

    return { blob, filename };
  }
};
```

### Testing Strategy

**Service Tests** (`apps/api/tests/test_services.py`):
```python
from django.test import TestCase
from survey_api.services.excel_export_service import ExcelExportService
from survey_api.models import CalculatedSurvey, InterpolatedSurvey
from openpyxl import load_workbook
import io

class ExcelExportServiceTest(TestCase):
    def setUp(self):
        # Create test data (calculated survey, run, etc.)
        pass

    def test_export_calculated_excel(self):
        """Test Excel export for calculated survey."""
        response = ExcelExportService.export_calculated_survey(
            self.calculated.id, 'xlsx'
        )

        self.assertEqual(response.status_code, 200)
        self.assertEqual(
            response['Content-Type'],
            'application/vnd.openxmlformats-officedocument.spreadsheetml.sheet'
        )

        # Load workbook from response
        wb = load_workbook(io.BytesIO(response.content))

        # Verify sheets exist
        self.assertIn('Metadata', wb.sheetnames)
        self.assertIn('Calculated Data', wb.sheetnames)

        # Verify data
        ws = wb['Calculated Data']
        self.assertEqual(ws['A1'].value, 'MD (m)')
        self.assertEqual(ws['A2'].value, self.calculated.survey_data.md_data[0])

    def test_filename_generation(self):
        """Test filename generation with sanitization."""
        filename = ExcelExportService._generate_filename(
            "Test Run #1", "calculated", "xlsx"
        )

        self.assertRegex(filename, r'^Test_Run__1_calculated_\d{8}_\d{6}\.xlsx$')
```

**API Tests** (`apps/api/tests/test_views.py`):
```python
from rest_framework.test import APIClient, APITestCase
from rest_framework import status

class ExportAPITest(APITestCase):
    def setUp(self):
        self.client = APIClient()
        self.user = User.objects.create_user(...)
        self.client.force_authenticate(user=self.user)

    def test_export_calculated_survey_xlsx(self):
        """Test calculated survey export endpoint (Excel)."""
        response = self.client.get(
            f'/api/surveys/export/calculated/{self.calculated.id}/?format=xlsx'
        )

        self.assertEqual(response.status_code, status.HTTP_200_OK)
        self.assertIn('attachment', response['Content-Disposition'])

    def test_export_invalid_format(self):
        """Test export with invalid format parameter."""
        response = self.client.get(
            f'/api/surveys/export/calculated/{self.calculated.id}/?format=pdf'
        )

        self.assertEqual(response.status_code, status.HTTP_400_BAD_REQUEST)
```

## Change Log

| Date | Version | Description | Author |
|------|---------|-------------|--------|
| 2025-10-13 | 1.0 | Initial story creation | Bob (Scrum Master) |

## Dev Agent Record

### Agent Model Used
claude-sonnet-4-5-20250929

### Debug Log References
- All 18 unit tests passing for Excel export service
- API endpoints tested manually (integration tests pending)
- Model relationship chain verified: CalculatedSurvey → SurveyData → SurveyFile → Run

### Completion Notes List
- **Backend Complete**: Excel/CSV export service fully functional with comprehensive error handling
- **API Endpoints**: Download endpoints created with authentication and format validation
- **Unit Tests**: 18 comprehensive tests covering service layer (Excel, CSV, calculated, interpolated)
- **Frontend Pending**: Task 8 (Download buttons) requires frontend implementation
- **Model Compatibility**: Fixed test fixtures to match actual Django model structure (TieOn, Location, Depth relationships)
- **Format Support**: Both Excel (.xlsx) and CSV (.csv) exports working
- **Professional Formatting**: Blue headers, proper number formats, metadata sheets

### File List
**Created:**
- `apps/api/survey_api/services/excel_export_service.py` (475 lines)
- `apps/api/survey_api/views/export_viewset.py` (101 lines)
- `apps/api/tests/test_excel_export_service.py` (470+ lines, 18 tests)

**Modified:**
- `apps/api/survey_api/urls.py` (added export endpoint routes)

## QA Results
_To be filled by QA agent_
