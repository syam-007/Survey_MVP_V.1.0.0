# Story 2.5: Well Management Frontend Pages

## Status
Ready for Development

## Story
**As a** survey engineer
**I want** web pages to create, view, and manage wells
**so that** I can interact with the Well Management API through a user-friendly interface and link wells to survey runs

## Acceptance Criteria
1. **Well List Page** (`/wells`) - Display paginated list of wells with filtering and search
2. **Create Well Page** (`/wells/new`) - Form to create new well with validation
3. **Well Detail Page** (`/wells/:id`) - Display well details with associated runs list
4. **Edit Well Page** (`/wells/:id/edit`) - Form to update existing well
5. **Delete Well Confirmation** - Modal to confirm delete with CASCADE warning
6. **Well Autocomplete Component** - Reusable autocomplete for linking wells to runs
7. **RTK Query Integration** - Use Redux Toolkit Query for well API calls with caching
8. **Material-UI Components** - Use MUI v7 components (Table, Form, Dialog, Autocomplete)
9. **Form Validation** - Use React Hook Form + Yup for client-side validation
10. **Routing** - React Router v7 routes for all well pages
11. **Error Handling** - Display user-friendly error messages for API failures with retry
12. **Loading States** - Show skeleton loaders during API calls
13. **TypeScript Strict Mode** - All code passes TypeScript strict compilation

## Background Context

### What's Already Available (Backend)

**From Story 2.2 - Well Management API:**
- ✅ GET `/api/v1/wells/` - List wells with pagination (20 per page)
- ✅ POST `/api/v1/wells/` - Create well with validation
- ✅ GET `/api/v1/wells/:id/` - Get well details with associated runs
- ✅ PUT `/api/v1/wells/:id/` - Update well
- ✅ DELETE `/api/v1/wells/:id/` - Hard delete (CASCADE sets run.well to NULL)
- ✅ Filter by well_type, search by well_name
- ✅ Pagination, authentication, permissions working

**Well Data Model:**
```typescript
interface Well {
  id: string;  // UUID
  well_name: string;  // unique, max 255 chars
  well_type: 'Oil' | 'Gas' | 'Water' | 'Other';
  runs_count: number;  // computed field
  runs: RunSummary[];  // nested array
  created_at: string;  // ISO 8601 datetime
  updated_at: string;  // ISO 8601 datetime
}

interface RunSummary {
  id: string;
  run_number: string;
  run_name: string;
  run_type: 'GTL' | 'Gyro' | 'MWD' | 'Unknown';
}

interface CreateWellInput {
  well_name: string;  // required, unique
  well_type: 'Oil' | 'Gas' | 'Water' | 'Other';  // required
}

interface WellFilters {
  well_type?: 'Oil' | 'Gas' | 'Water' | 'Other';
  search?: string;  // search well_name
  ordering?: 'created_at' | '-created_at' | 'well_name' | '-well_name';
  page?: number;
  page_size?: number;  // default 20, max 100
}

interface PaginatedWellResponse {
  count: number;
  next: string | null;
  previous: string | null;
  page: number;
  total_pages: number;
  page_size: number;
  results: Well[];
}
```

### What Exists from Story 2.4

**From Story 2.4 - Run Management Frontend:**
- ✅ RTK Query pattern established (apps/web/src/stores/runsSlice.ts)
- ✅ Common components (PageHeader, ErrorAlert, SkeletonLoader, ConfirmDialog, SuccessSnackbar)
- ✅ Form validation pattern with React Hook Form + Yup
- ✅ Routing structure with React Router v7
- ✅ Material-UI v7 components usage (Table, Form, Dialog, TextField, Select, etc.)
- ✅ Authentication integrated (JWT tokens in Redux)
- ✅ Service layer pattern (apps/web/src/services/runsService.ts)
- ✅ TypeScript types (apps/web/src/types/run.types.ts)

**Note:** Story 2.4 has CRITICAL test failures that need to be addressed in a separate story (Story 2.6 recommended). This story will follow the same patterns but MUST include test execution validation before marking complete.

## Tasks / Subtasks

- [ ] Task 1: Create Well TypeScript Types (AC: All)
  - [ ] Create `apps/web/src/types/well.types.ts`
  - [ ] Define Well interface matching API response
  - [ ] Define CreateWellInput interface for POST/PUT
  - [ ] Define WellFilters interface for query params
  - [ ] Define PaginatedWellResponse interface
  - [ ] Export all types
  - [ ] Ensure types match backend API exactly (reference Story 2.2)

- [ ] Task 2: Create Well Service Layer (AC: 7)
  - [ ] Create `apps/web/src/services/wellsService.ts`
  - [ ] Import axios and well types
  - [ ] Create WellsService class with axios instance
  - [ ] Configure baseURL from VITE_API_URL environment variable
  - [ ] Add JWT token to request headers via axios interceptors
  - [ ] Implement token refresh logic on 401 errors
  - [ ] Implement `getWells(filters?: WellFilters)` method
    - [ ] Build query params from WellFilters
    - [ ] Return PaginatedWellResponse
  - [ ] Implement `getWellById(id: string)` method
    - [ ] Return Well with nested runs
  - [ ] Implement `createWell(data: CreateWellInput)` method
    - [ ] Return created Well
  - [ ] Implement `updateWell(id: string, data: CreateWellInput)` method
    - [ ] Return updated Well
  - [ ] Implement `deleteWell(id: string)` method
    - [ ] Return void on success
  - [ ] Implement error handling with user-friendly messages
  - [ ] Export singleton instance
  - [ ] Write unit tests: `apps/web/src/services/__tests__/wellsService.test.ts` (20 tests)
    - [ ] Test getWells with and without filters
    - [ ] Test getWellById success and 404
    - [ ] Test createWell success and validation errors
    - [ ] Test updateWell success and errors
    - [ ] Test deleteWell success and 404
    - [ ] Test error handling for all status codes
    - [ ] Test JWT token attachment
    - [ ] Test token refresh on 401
    - [ ] **EXECUTE TESTS** and verify all 20 pass before proceeding

- [ ] Task 3: Create RTK Query Wells Slice (AC: 7)
  - [ ] Create `apps/web/src/stores/wellsSlice.ts`
  - [ ] Import RTK Query createApi, fetchBaseQuery
  - [ ] Import Well types from well.types.ts
  - [ ] Import RootState for auth token access
  - [ ] Create wellsApi using createApi
  - [ ] Configure baseQuery with API_BASE_URL and prepareHeaders for JWT
  - [ ] Define cache tag types: ['Well']
  - [ ] Implement getWells query endpoint
    - [ ] Accept WellFilters parameter
    - [ ] Build query string from filters
    - [ ] Return PaginatedWellResponse
    - [ ] Provide cache tag: { type: 'Well', id: 'LIST' }
  - [ ] Implement getWellById query endpoint
    - [ ] Accept id parameter
    - [ ] Return Well with nested runs
    - [ ] Provide cache tag: { type: 'Well', id }
  - [ ] Implement createWell mutation endpoint
    - [ ] Accept CreateWellInput
    - [ ] Return created Well
    - [ ] Invalidate tags: [{ type: 'Well', id: 'LIST' }]
  - [ ] Implement updateWell mutation endpoint
    - [ ] Accept { id, data } parameter
    - [ ] Return updated Well
    - [ ] Invalidate tags: [{ type: 'Well', id }, { type: 'Well', id: 'LIST' }]
  - [ ] Implement deleteWell mutation endpoint
    - [ ] Accept id parameter
    - [ ] Return void
    - [ ] Invalidate tags: [{ type: 'Well', id }, { type: 'Well', id: 'LIST' }]
  - [ ] Export auto-generated hooks
  - [ ] Register wellsApi in store configuration
  - [ ] Write unit tests: `apps/web/src/stores/__tests__/wellsSlice.test.ts` (20 tests)
    - [ ] Test endpoint definitions
    - [ ] Test query URL building
    - [ ] Test cache tag configuration
    - [ ] Test cache invalidation strategy
    - [ ] **EXECUTE TESTS** and verify all 20 pass before proceeding

- [ ] Task 4: Create Well List Page (AC: 1, 8, 10, 11, 12)
  - [ ] Create `apps/web/src/pages/wells/WellListPage.tsx`
  - [ ] Import MUI components (Container, Paper, Table, TableBody, TableCell, TableContainer, TableHead, TableRow, TablePagination, IconButton, Chip, Button, TextField, Select, MenuItem, FormControl, InputLabel)
  - [ ] Import MUI icons (Add, Edit, Delete, Visibility)
  - [ ] Import common components (PageHeader, ErrorAlert, SkeletonLoader, ConfirmDialog, SuccessSnackbar)
  - [ ] Import RTK Query hooks (useGetWellsQuery, useDeleteWellMutation)
  - [ ] Import React Router navigation (useNavigate)
  - [ ] Define WellListPage component
  - [ ] Implement filters state (well_type, search, ordering, page, page_size)
  - [ ] Use useGetWellsQuery with filters
  - [ ] Render PageHeader with title "Wells" and "Create Well" button
  - [ ] Render filter controls (well_type dropdown, search input, ordering dropdown)
  - [ ] Render loading state with SkeletonLoader (10 rows, table variant)
  - [ ] Render error state with ErrorAlert and retry button
  - [ ] Render MUI Table with columns: Well Name, Type, Runs Count, Created At, Actions
  - [ ] Render Chip for well_type with colors (Oil: primary, Gas: secondary, Water: success, Other: default)
  - [ ] Render action icons: View (navigate to detail), Edit (navigate to edit), Delete (open confirm dialog)
  - [ ] Render TablePagination component with page/page_size controls
  - [ ] Implement handleFilterChange to update filters state
  - [ ] Implement handleSearch to apply search filter
  - [ ] Implement handlePageChange for pagination
  - [ ] Implement handlePageSizeChange for rows per page
  - [ ] Implement handleDeleteClick to open confirm dialog
  - [ ] Implement handleDeleteConfirm to call deleteWell mutation
  - [ ] Show success snackbar after delete
  - [ ] Handle empty results (show "No wells found" message with "Create First Well" button)
  - [ ] Export WellListPage component
  - [ ] Write integration tests: `apps/web/src/pages/__tests__/WellListPage.test.tsx` (27 tests)
    - [ ] Test page rendering with data
    - [ ] Test loading state
    - [ ] Test error state with retry
    - [ ] Test filtering by well_type
    - [ ] Test search functionality
    - [ ] Test pagination
    - [ ] Test sorting
    - [ ] Test navigation to detail page
    - [ ] Test navigation to edit page
    - [ ] Test delete confirmation flow
    - [ ] Test empty state
    - [ ] **EXECUTE TESTS** and verify all 27 pass before proceeding

- [ ] Task 5: Create Well Form Component (AC: 2, 4, 9, 11, 12)
  - [ ] Create `apps/web/src/components/forms/WellForm.tsx`
  - [ ] Import React Hook Form (useForm, Controller)
  - [ ] Import Yup validation (@hookform/resolvers/yup)
  - [ ] Import MUI components (Box, TextField, FormControl, InputLabel, Select, MenuItem, Button, Paper, Typography, FormHelperText, Stack)
  - [ ] Define Yup validation schema
    - [ ] well_name: required, max 255 chars, unique (API validation)
    - [ ] well_type: required, one of Oil/Gas/Water/Other
  - [ ] Define WellFormProps interface
    - [ ] initialValues?: Partial<CreateWellInput>
    - [ ] onSubmit: (data: CreateWellInput) => void
    - [ ] onCancel: () => void
    - [ ] isSubmitting?: boolean
    - [ ] submitLabel?: string
  - [ ] Create WellForm component
  - [ ] Use useForm with Yup resolver
  - [ ] Implement form fields:
    - [ ] Well Name (TextField, required, validation error display)
    - [ ] Well Type (Select dropdown with Oil/Gas/Water/Other options)
  - [ ] Implement form reset on initialValues change (useEffect)
  - [ ] Implement form submission with validated data
  - [ ] Display field-specific validation errors
  - [ ] Disable form during submission
  - [ ] Render Cancel and Submit buttons
  - [ ] Make form responsive (Stack with direction: row on md+, column on xs)
  - [ ] Export WellForm component
  - [ ] Write unit tests: `apps/web/src/components/forms/__tests__/WellForm.test.tsx` (15 tests)
    - [ ] Test form renders with initial values
    - [ ] Test form validation (required fields, max length)
    - [ ] Test form submission with valid data
    - [ ] Test form submission with invalid data
    - [ ] Test cancel button
    - [ ] Test disabled state during submission
    - [ ] **EXECUTE TESTS** and verify all 15 pass before proceeding

- [ ] Task 6: Create Well Detail Page (AC: 3, 8, 10, 11, 12)
  - [ ] Create `apps/web/src/pages/wells/WellDetailPage.tsx`
  - [ ] Import MUI components (Container, Box, Typography, Chip, Button, Card, CardContent, Stack, Divider, Table, TableBody, TableCell, TableHead, TableRow)
  - [ ] Import MUI icons (Edit, Delete, ArrowBack)
  - [ ] Import common components (PageHeader, ErrorAlert, ConfirmDialog, SuccessSnackbar, SkeletonLoader)
  - [ ] Import RTK Query hooks (useGetWellByIdQuery, useDeleteWellMutation)
  - [ ] Import React Router (useParams, useNavigate)
  - [ ] Define WellDetailPage component
  - [ ] Use useParams to get well id from URL
  - [ ] Use useGetWellByIdQuery to fetch well data
  - [ ] Render loading state with SkeletonLoader (detail variant)
  - [ ] Render error state with ErrorAlert and back button
  - [ ] Render PageHeader with well_name as title and breadcrumbs (Home > Wells > Well Name)
  - [ ] Render action buttons: Back, Edit, Delete
  - [ ] Render well information card with:
    - [ ] Well Name
    - [ ] Well Type (Chip with color)
    - [ ] Runs Count
    - [ ] Created At (formatted with date-fns)
    - [ ] Updated At (formatted with date-fns)
  - [ ] Render associated runs section with MUI Table
    - [ ] Table columns: Run Number, Run Name, Type, Actions (View Run button)
    - [ ] Link to run detail page on View Run click
    - [ ] Show "No runs associated" if runs array is empty
  - [ ] Implement delete confirmation dialog
  - [ ] Add CASCADE warning in delete dialog message
  - [ ] Implement handleDelete to call deleteWell mutation
  - [ ] Show success snackbar after delete
  - [ ] Navigate to /wells after successful delete
  - [ ] Export WellDetailPage component
  - [ ] Write integration tests: `apps/web/src/pages/__tests__/WellDetailPage.test.tsx` (31 tests)
    - [ ] Test page rendering with well data
    - [ ] Test loading state
    - [ ] Test error state
    - [ ] Test 404 not found
    - [ ] Test well information display
    - [ ] Test associated runs table
    - [ ] Test empty runs state
    - [ ] Test navigation to edit page
    - [ ] Test navigation to run detail page
    - [ ] Test delete confirmation flow
    - [ ] Test back button navigation
    - [ ] **EXECUTE TESTS** and verify all 31 pass before proceeding

- [ ] Task 7: Create Well Create Page (AC: 2, 8, 10, 11, 12)
  - [ ] Create `apps/web/src/pages/wells/WellCreatePage.tsx`
  - [ ] Import MUI components (Container)
  - [ ] Import common components (PageHeader, ErrorAlert)
  - [ ] Import WellForm component
  - [ ] Import RTK Query hook (useCreateWellMutation)
  - [ ] Import React Router (useNavigate)
  - [ ] Define WellCreatePage component
  - [ ] Use useCreateWellMutation hook
  - [ ] Render PageHeader with title "Create Well" and breadcrumbs (Home > Wells > Create)
  - [ ] Render WellForm with empty initial values
  - [ ] Implement handleSubmit to call createWell mutation
  - [ ] Show loading state during submission (isSubmitting prop to WellForm)
  - [ ] Display API errors with ErrorAlert (duplicate name, etc.)
  - [ ] Navigate to well detail page on success
  - [ ] Implement handleCancel to navigate back to /wells
  - [ ] Export WellCreatePage component
  - [ ] Write integration tests: `apps/web/src/pages/__tests__/WellCreatePage.test.tsx` (12 tests)
    - [ ] Test page rendering
    - [ ] Test form submission with valid data
    - [ ] Test navigation to detail page on success
    - [ ] Test API error display (duplicate name)
    - [ ] Test cancel navigation
    - [ ] Test loading state during submission
    - [ ] **EXECUTE TESTS** and verify all 12 pass before proceeding

- [ ] Task 8: Create Well Edit Page (AC: 4, 8, 10, 11, 12)
  - [ ] Create `apps/web/src/pages/wells/WellEditPage.tsx`
  - [ ] Import MUI components (Container)
  - [ ] Import common components (PageHeader, ErrorAlert, SkeletonLoader)
  - [ ] Import WellForm component
  - [ ] Import RTK Query hooks (useGetWellByIdQuery, useUpdateWellMutation)
  - [ ] Import React Router (useParams, useNavigate)
  - [ ] Define WellEditPage component
  - [ ] Use useParams to get well id from URL
  - [ ] Use useGetWellByIdQuery to fetch current well data
  - [ ] Use useUpdateWellMutation hook
  - [ ] Render loading state while fetching well data
  - [ ] Render error state if well not found (404)
  - [ ] Render PageHeader with title "Edit Well" and breadcrumbs (Home > Wells > Well Name > Edit)
  - [ ] Render WellForm with current well data as initial values
  - [ ] Implement handleSubmit to call updateWell mutation
  - [ ] Show loading state during submission
  - [ ] Display API errors with ErrorAlert
  - [ ] Navigate to well detail page on success
  - [ ] Implement handleCancel to navigate back to well detail page
  - [ ] Export WellEditPage component
  - [ ] Write integration tests: `apps/web/src/pages/__tests__/WellEditPage.test.tsx` (14 tests)
    - [ ] Test page rendering with well data
    - [ ] Test loading state while fetching
    - [ ] Test 404 error handling
    - [ ] Test form pre-population with well data
    - [ ] Test form submission with updated data
    - [ ] Test navigation to detail page on success
    - [ ] Test API error display
    - [ ] Test cancel navigation
    - [ ] **EXECUTE TESTS** and verify all 14 pass before proceeding

- [ ] Task 9: Create Well Autocomplete Component (AC: 6, 8, 11, 12)
  - [ ] Create `apps/web/src/components/common/WellAutocomplete.tsx`
  - [ ] Import MUI Autocomplete component
  - [ ] Import RTK Query hook (useGetWellsQuery)
  - [ ] Import debounce from lodash or custom implementation
  - [ ] Define WellAutocompleteProps interface
    - [ ] value: string | null (well id)
    - [ ] onChange: (wellId: string | null) => void
    - [ ] label?: string
    - [ ] error?: string
    - [ ] disabled?: boolean
  - [ ] Create WellAutocomplete component
  - [ ] Implement search state for autocomplete input
  - [ ] Use useGetWellsQuery with search filter (debounced)
  - [ ] Render MUI Autocomplete component
  - [ ] Configure options as wells from query result
  - [ ] Configure getOptionLabel to show well_name
  - [ ] Configure renderOption to show well_name and type chip
  - [ ] Configure loading state during API call
  - [ ] Configure noOptionsText for empty results
  - [ ] Implement debounced search (300ms delay)
  - [ ] Handle value selection and call onChange prop
  - [ ] Display error message if provided
  - [ ] Export WellAutocomplete component
  - [ ] Write unit tests: `apps/web/src/components/common/__tests__/WellAutocomplete.test.tsx` (10 tests)
    - [ ] Test autocomplete rendering
    - [ ] Test search functionality with debounce
    - [ ] Test option selection
    - [ ] Test loading state
    - [ ] Test error display
    - [ ] Test disabled state
    - [ ] **EXECUTE TESTS** and verify all 10 pass before proceeding

- [ ] Task 10: Update Well Routes in React Router (AC: 10)
  - [ ] Open `apps/web/src/App.tsx` or routing configuration file
  - [ ] Import well page components (WellListPage, WellCreatePage, WellDetailPage, WellEditPage)
  - [ ] Add routes for wells:
    - [ ] `/wells` → WellListPage
    - [ ] `/wells/new` → WellCreatePage
    - [ ] `/wells/:id` → WellDetailPage
    - [ ] `/wells/:id/edit` → WellEditPage
  - [ ] Ensure routes require authentication (wrap in ProtectedRoute if needed)
  - [ ] Test navigation between all well pages
  - [ ] Verify URL params work correctly (:id parameter)

- [ ] Task 11: Update Navigation Menu to Include Wells (AC: 10)
  - [ ] Open main navigation component (e.g., `apps/web/src/components/layout/Sidebar.tsx` or `Navigation.tsx`)
  - [ ] Add "Wells" navigation link
  - [ ] Use appropriate icon for wells (e.g., WaterIcon or LayersIcon)
  - [ ] Link to `/wells` route
  - [ ] Position near "Runs" link in navigation menu
  - [ ] Test navigation from menu to wells list page

- [ ] Task 12: Integrate WellAutocomplete into Run Form (AC: 6)
  - [ ] Open `apps/web/src/components/forms/RunForm.tsx`
  - [ ] Import WellAutocomplete component
  - [ ] Add well field to form (optional, nullable)
  - [ ] Replace any existing well input with WellAutocomplete
  - [ ] Wire up WellAutocomplete value to form state
  - [ ] Wire up WellAutocomplete onChange to form state update
  - [ ] Display validation errors if any
  - [ ] Test well selection in run create/edit flows
  - [ ] Verify well data is sent to API on form submission

- [ ] Task 13: Write E2E Tests for Well Management (AC: All)
  - [ ] Create `apps/web/e2e/wells.spec.ts`
  - [ ] Set up test user login before each test
  - [ ] Test AC1: List wells page
    - [ ] Navigate to /wells
    - [ ] Verify table displays wells
    - [ ] Verify filter controls present
    - [ ] Verify pagination works
  - [ ] Test AC1: Filter wells by type
    - [ ] Select "Oil" from well_type dropdown
    - [ ] Click Apply Filters
    - [ ] Verify only Oil wells displayed
  - [ ] Test AC1: Search wells by name
    - [ ] Enter "Test" in search input
    - [ ] Click Apply Filters
    - [ ] Verify filtered results
  - [ ] Test AC2: Create well workflow
    - [ ] Click "Create Well" button
    - [ ] Navigate to /wells/new
    - [ ] Fill well_name and well_type
    - [ ] Click Submit
    - [ ] Verify redirect to well detail page
    - [ ] Verify well appears in list
  - [ ] Test AC2: Create well validation
    - [ ] Navigate to /wells/new
    - [ ] Submit empty form
    - [ ] Verify validation errors displayed
  - [ ] Test AC3: View well detail
    - [ ] Click on a well in list
    - [ ] Navigate to /wells/:id
    - [ ] Verify well information displayed
    - [ ] Verify associated runs table
  - [ ] Test AC4: Edit well workflow
    - [ ] Navigate to well detail page
    - [ ] Click Edit button
    - [ ] Navigate to /wells/:id/edit
    - [ ] Update well_name
    - [ ] Click Submit
    - [ ] Verify redirect to detail page
    - [ ] Verify updated data displayed
  - [ ] Test AC5: Delete well workflow
    - [ ] Navigate to well detail page
    - [ ] Click Delete button
    - [ ] Verify confirmation dialog with CASCADE warning
    - [ ] Click Confirm
    - [ ] Verify redirect to /wells
    - [ ] Verify well removed from list
  - [ ] Test AC6: Well autocomplete in run form
    - [ ] Navigate to /runs/new
    - [ ] Click well autocomplete field
    - [ ] Type well name
    - [ ] Verify autocomplete suggestions
    - [ ] Select a well
    - [ ] Submit form
    - [ ] Verify run created with well association
  - [ ] Run all E2E tests: `npm run test:e2e`
  - [ ] Verify all 21 E2E tests pass
  - [ ] **CRITICAL**: Execute tests and document results before marking story complete

- [ ] Task 14: TypeScript Compilation Verification (AC: 13)
  - [ ] Run TypeScript compiler: `npm run build`
  - [ ] Verify no TypeScript errors
  - [ ] Ensure strict mode compliance
  - [ ] Fix any type errors before marking complete
  - [ ] Document build success in Dev Agent Record

- [ ] Task 15: Test Execution and Documentation (CRITICAL)
  - [ ] Execute all unit tests: `npm test`
  - [ ] Verify test results: Expected 159 tests (20 + 20 + 27 + 15 + 31 + 12 + 14 + 10 + 10)
  - [ ] Execute E2E tests: `npm run test:e2e`
  - [ ] Verify E2E results: Expected 21 tests
  - [ ] Document test execution in Dev Agent Record
  - [ ] Update story Test Results section with actual numbers
  - [ ] **CRITICAL**: Do NOT mark story complete without test execution proof
  - [ ] Take screenshot of test results or paste output in Dev Agent Record

## Dev Notes

### Critical Lessons from Story 2.4
[Source: Story 2.4 QA Review]

**CRITICAL TEST FAILURE ISSUE:**
Story 2.4 had 123 tests written but NEVER EXECUTED. When QA agent ran tests, all 4 test suites failed TypeScript compilation with errors:
- Missing dependencies (jest-environment-jsdom)
- Type mismatches (PaginatedRunResponse structure)
- Import errors (@testing-library/react exports)
- RTK Query API misuse (accessing .query property incorrectly)
- esModuleInterop configuration issues

**MANDATORY FOR STORY 2.5:**
1. Execute tests IMMEDIATELY after writing them (per task)
2. Verify tests compile and pass before proceeding to next task
3. Fix test failures before marking tasks complete
4. Document test execution in Dev Agent Record with actual results
5. Do NOT mark story complete without proof of passing tests

**Test Execution Checkpoints:**
- After Task 2: Run service tests (20 tests)
- After Task 3: Run slice tests (20 tests)
- After Task 4: Run list page tests (27 tests)
- After Task 5: Run form tests (15 tests)
- After Task 6: Run detail page tests (31 tests)
- After Task 7: Run create page tests (12 tests)
- After Task 8: Run edit page tests (14 tests)
- After Task 9: Run autocomplete tests (10 tests)
- After Task 13: Run all E2E tests (21 tests)
- Before marking complete: Run full test suite and verify ALL PASS

### Frontend Architecture from Story 2.4
[Source: Story 2.4 Implementation]

**Story 2.4 COMPLETE (with test issues):**
- Run Management Frontend fully implemented
- RTK Query pattern established with cache invalidation
- Common components created and reusable
- Material-UI v7 Grid compatibility issues resolved (use Stack/Box instead of Grid item)
- React Hook Form + Yup validation pattern working
- Service layer with axios interceptors for token refresh
- TypeScript strict mode passing

**Components Available for Reuse:**
- `apps/web/src/components/common/PageHeader.tsx` - Page titles with breadcrumbs and actions
- `apps/web/src/components/common/ErrorAlert.tsx` - Error display with retry button
- `apps/web/src/components/common/SkeletonLoader.tsx` - Loading placeholders (table, detail, form variants)
- `apps/web/src/components/common/ConfirmDialog.tsx` - Confirmation dialogs with severity levels
- `apps/web/src/components/common/SuccessSnackbar.tsx` - Success notifications

**RTK Query Pattern:**
```typescript
// apps/web/src/stores/wellsSlice.ts
export const wellsApi = createApi({
  reducerPath: 'wellsApi',
  baseQuery: fetchBaseQuery({
    baseUrl: `${API_BASE_URL}/api/v1`,
    prepareHeaders: (headers, { getState }) => {
      const token = (getState() as RootState).auth.tokens?.access;
      if (token) {
        headers.set('Authorization', `Bearer ${token}`);
      }
      return headers;
    },
  }),
  tagTypes: ['Well'],
  endpoints: (builder) => ({
    getWells: builder.query<PaginatedWellResponse, WellFilters | void>({
      query: (filters) => {
        const params = new URLSearchParams();
        // Build query params from filters
        return { url: `/wells/?${params.toString()}` };
      },
      providesTags: () => [{ type: 'Well', id: 'LIST' }],
    }),
    // ... other endpoints
  }),
});

export const {
  useGetWellsQuery,
  useGetWellByIdQuery,
  useCreateWellMutation,
  useUpdateWellMutation,
  useDeleteWellMutation,
} = wellsApi;
```

**Form Pattern:**
```typescript
// React Hook Form + Yup validation
import { useForm, Controller } from 'react-hook-form';
import { yupResolver } from '@hookform/resolvers/yup';
import * as yup from 'yup';

const wellSchema = yup.object({
  well_name: yup.string().required('Well name is required').max(255),
  well_type: yup.mixed<WellType>().oneOf(['Oil', 'Gas', 'Water', 'Other']).required(),
});

const { control, handleSubmit, formState: { errors } } = useForm<CreateWellInput>({
  resolver: yupResolver(wellSchema) as any,
  defaultValues: initialValues,
});
```

**Material-UI v7 Notes:**
- DO NOT use `<Grid item>` - causes compilation errors
- Use `<Stack>` or `<Box>` for layout instead
- Use `<Stack direction="row" spacing={2}>` for horizontal layouts
- Use `<Stack spacing={2}>` for vertical layouts

### TypeScript Type Definitions
[Source: apps/web/src/types/run.types.ts]

**Well Types to Define:**
```typescript
// apps/web/src/types/well.types.ts
export type WellType = 'Oil' | 'Gas' | 'Water' | 'Other';

export interface Well {
  id: string;
  well_name: string;
  well_type: WellType;
  runs_count: number;
  runs: RunSummary[];
  created_at: string;
  updated_at: string;
}

export interface RunSummary {
  id: string;
  run_number: string;
  run_name: string;
  run_type: 'GTL' | 'Gyro' | 'MWD' | 'Unknown';
}

export interface CreateWellInput {
  well_name: string;
  well_type: WellType;
}

export interface WellFilters {
  well_type?: WellType;
  search?: string;
  ordering?: 'created_at' | '-created_at' | 'well_name' | '-well_name';
  page?: number;
  page_size?: number;
}

export interface PaginatedWellResponse {
  count: number;
  next: string | null;
  previous: string | null;
  page: number;
  total_pages: number;
  page_size: number;
  results: Well[];
}
```

### Well API Endpoints
[Source: Story 2.2 - Well Management API]

**Well API Endpoints:**
```
GET    /api/v1/wells/                 - List wells (paginated)
POST   /api/v1/wells/                 - Create well
GET    /api/v1/wells/:id/             - Get well details
PUT    /api/v1/wells/:id/             - Update well
DELETE /api/v1/wells/:id/             - Delete well (CASCADE)
```

**Query Parameters:**
- `well_type`: Oil | Gas | Water | Other
- `search`: well_name (case-insensitive partial match)
- `ordering`: created_at | -created_at | well_name | -well_name
- `page`: integer (default 1)
- `page_size`: integer (default 20, max 100)

**Response Status Codes:**
- 200 OK: Successful GET, PUT
- 201 Created: Successful POST
- 204 No Content: Successful DELETE
- 400 Bad Request: Validation error (duplicate name, invalid type)
- 401 Unauthorized: Missing/invalid JWT token
- 403 Forbidden: Insufficient permissions
- 404 Not Found: Well not found
- 500 Internal Server Error: Server error

### Testing Strategy
[Source: Story 2.4 Testing Patterns + QA Review Learnings]

**Frontend Well Tests:**

**Unit Tests (Service Layer - 20 tests):**
```typescript
// apps/web/src/services/__tests__/wellsService.test.ts
import MockAdapter from 'axios-mock-adapter';
import wellsService from '../wellsService';

describe('WellsService', () => {
  let mockAxios: MockAdapter;

  beforeEach(() => {
    mockAxios = new MockAdapter(wellsService['api']);
  });

  it('should fetch wells with filters', async () => {
    const mockData = { count: 2, results: [well1, well2] };
    mockAxios.onGet('/wells/').reply(200, mockData);

    const result = await wellsService.getWells({ well_type: 'Oil' });

    expect(result.count).toBe(2);
    expect(result.results).toHaveLength(2);
  });

  // ... 19 more tests
});
```

**Unit Tests (RTK Query Slice - 20 tests):**
```typescript
// apps/web/src/stores/__tests__/wellsSlice.test.ts
import { configureStore } from '@reduxjs/toolkit';
import { wellsApi } from '../wellsSlice';

describe('wellsSlice', () => {
  it('should build correct URL with filters', () => {
    const { query } = wellsApi.endpoints.getWells;
    const result = query({ well_type: 'Oil', search: 'test' });

    expect(result.url).toContain('well_type=Oil');
    expect(result.url).toContain('search=test');
  });

  it('should invalidate cache on createWell', () => {
    const { invalidatesTags } = wellsApi.endpoints.createWell;
    const tags = invalidatesTags(mockWell, undefined, mockInput);

    expect(tags).toEqual([{ type: 'Well', id: 'LIST' }]);
  });

  // ... 18 more tests
});
```

**Integration Tests (React Components - 109 tests):**
- WellListPage: 27 tests (rendering, filtering, pagination, delete flow)
- WellForm: 15 tests (validation, submission, error handling)
- WellDetailPage: 31 tests (display, navigation, delete)
- WellCreatePage: 12 tests (create flow, errors)
- WellEditPage: 14 tests (edit flow, pre-population)
- WellAutocomplete: 10 tests (search, selection, debounce)

**E2E Tests (Playwright - 21 tests):**
```typescript
// apps/web/e2e/wells.spec.ts
import { test, expect } from '@playwright/test';

test.describe('Well Management E2E', () => {
  test.beforeEach(async ({ page }) => {
    // Login
    await page.goto('/login');
    await page.fill('input[name="email"]', 'test@example.com');
    await page.fill('input[name="password"]', 'testpassword');
    await page.click('button[type="submit"]');
    await page.waitForURL('/dashboard');
  });

  test('should create a well', async ({ page }) => {
    await page.goto('/wells/new');
    await page.fill('input[name="well_name"]', 'E2E Test Well');
    await page.selectOption('select[name="well_type"]', 'Oil');
    await page.click('button[type="submit"]');

    await page.waitForURL(/\/wells\/.+/);
    await expect(page.getByText('E2E Test Well')).toBeVisible();
  });

  // ... 20 more E2E tests
});
```

**Test Execution Requirements:**
1. Run tests after EVERY task completion
2. Verify tests pass before moving to next task
3. Fix any test failures immediately
4. Document test execution in Dev Agent Record
5. Total expected tests: 180 tests (20 + 20 + 109 + 21 + 10 for autocomplete)
6. Minimum 80% code coverage required

**Test Execution Commands:**
```bash
# Run all unit tests
cd apps/web && npm test

# Run specific test file
npm test wellsService.test.ts

# Run tests with coverage
npm test -- --coverage

# Run E2E tests
npm run test:e2e

# Run E2E tests in UI mode
npm run test:e2e:ui
```

### File Locations
[Source: docs/architecture/source-tree.md]

**Frontend Files to Create:**
- Types: `apps/web/src/types/well.types.ts`
- Service: `apps/web/src/services/wellsService.ts`
- Store: `apps/web/src/stores/wellsSlice.ts`
- Pages: `apps/web/src/pages/wells/WellListPage.tsx`
- Pages: `apps/web/src/pages/wells/WellCreatePage.tsx`
- Pages: `apps/web/src/pages/wells/WellDetailPage.tsx`
- Pages: `apps/web/src/pages/wells/WellEditPage.tsx`
- Component: `apps/web/src/components/forms/WellForm.tsx`
- Component: `apps/web/src/components/common/WellAutocomplete.tsx`
- E2E Tests: `apps/web/e2e/wells.spec.ts`

**Frontend Files to Modify:**
- Routes: `apps/web/src/App.tsx` (add well routes)
- Store: `apps/web/src/stores/store.ts` (register wellsApi)
- Navigation: `apps/web/src/components/layout/Sidebar.tsx` or similar (add wells link)
- Run Form: `apps/web/src/components/forms/RunForm.tsx` (integrate WellAutocomplete)

**Frontend Files to Reuse (from Story 2.4):**
- `apps/web/src/components/common/PageHeader.tsx`
- `apps/web/src/components/common/ErrorAlert.tsx`
- `apps/web/src/components/common/SkeletonLoader.tsx`
- `apps/web/src/components/common/ConfirmDialog.tsx`
- `apps/web/src/components/common/SuccessSnackbar.tsx`

**Test Files to Create:**
- `apps/web/src/services/__tests__/wellsService.test.ts` (20 tests)
- `apps/web/src/stores/__tests__/wellsSlice.test.ts` (20 tests)
- `apps/web/src/pages/__tests__/WellListPage.test.tsx` (27 tests)
- `apps/web/src/components/forms/__tests__/WellForm.test.tsx` (15 tests)
- `apps/web/src/pages/__tests__/WellDetailPage.test.tsx` (31 tests)
- `apps/web/src/pages/__tests__/WellCreatePage.test.tsx` (12 tests)
- `apps/web/src/pages/__tests__/WellEditPage.test.tsx` (14 tests)
- `apps/web/src/components/common/__tests__/WellAutocomplete.test.tsx` (10 tests)
- `apps/web/e2e/wells.spec.ts` (21 tests)

### Technical Constraints
[Source: docs/architecture/tech-stack.md]

**Stack:**
- React 19.1+ (upgraded from 18.2, noted in Story 2.4)
- TypeScript 5.9 strict mode
- Material-UI v7.3+ (v7 has breaking Grid changes)
- Redux Toolkit 2.9+ with RTK Query
- React Router v7.9+
- React Hook Form 7.64+
- Yup 1.7+ for validation
- Axios 1.12+ for HTTP calls
- date-fns 4.1+ for date formatting
- Vite 7.1+ for bundling
- Jest 30.2+ for unit tests
- Playwright 1.56+ for E2E tests

**Best Practices:**
- Use RTK Query for all API calls (no direct axios calls in components)
- Use React Hook Form for all forms
- Use Yup schemas for validation
- Use Material-UI v7 components (avoid Grid item syntax)
- Use Stack/Box for layouts instead of Grid
- Implement loading states with SkeletonLoader
- Implement error states with ErrorAlert and retry
- Use ConfirmDialog for destructive actions
- Use SuccessSnackbar for success feedback
- TypeScript strict mode required
- All components must be functional components with hooks
- No class components
- Export components as named exports (except pages can use default)

**Key Differences from Run Management (Story 2.4):**
- Well model is simpler (no location, depth, nested objects)
- Well form has only 2 fields (well_name, well_type)
- Well detail page includes associated runs table
- WellAutocomplete is a new reusable component (will be used in Run form)
- DELETE shows CASCADE warning (deleting well sets run.well to NULL)
- No well autocomplete deferral (AC#6 must be implemented in this story)

### Known Issues and Limitations
[Source: Story 2.4 QA Review]

**From Story 2.4:**
- Authentication bypass: All users have admin access (hardcoded canEdit=true)
- This will be addressed in a future story (Story 2.6 recommended)
- For now, Story 2.5 will follow same pattern (canEdit=true)

**CASCADE Behavior:**
- Deleting a well sets run.well to NULL (does not delete runs)
- Must display clear warning in delete confirmation dialog
- UI should show "This will unlink X associated runs" message

**Well Autocomplete Requirements:**
- Must implement debounced search (300ms delay)
- Must show loading state during search
- Must display well_name and type chip in dropdown
- Must integrate into Run form (create and edit)
- This is deferred from Story 2.4 and MUST be completed in Story 2.5

## Testing

### Test File Locations
- Well Service Tests: `apps/web/src/services/__tests__/wellsService.test.ts`
- Well Slice Tests: `apps/web/src/stores/__tests__/wellsSlice.test.ts`
- Well List Page Tests: `apps/web/src/pages/__tests__/WellListPage.test.tsx`
- Well Form Tests: `apps/web/src/components/forms/__tests__/WellForm.test.tsx`
- Well Detail Page Tests: `apps/web/src/pages/__tests__/WellDetailPage.test.tsx`
- Well Create Page Tests: `apps/web/src/pages/__tests__/WellCreatePage.test.tsx`
- Well Edit Page Tests: `apps/web/src/pages/__tests__/WellEditPage.test.tsx`
- Well Autocomplete Tests: `apps/web/src/components/common/__tests__/WellAutocomplete.test.tsx`
- E2E Tests: `apps/web/e2e/wells.spec.ts`

### Test Standards
- Use Jest for unit and integration tests
- Use React Testing Library for component tests
- Use Playwright for E2E tests
- Mock axios with axios-mock-adapter for service tests
- Mock RTK Query with store.dispatch(api.util.upsertQueryData) for integration tests
- Use @testing-library/user-event for user interactions
- Test both success and error scenarios
- Test loading states and error states
- Test form validation (client-side and API errors)
- Test navigation and routing
- Minimum 80% code coverage required
- **CRITICAL**: Execute tests after each task and verify they pass

### Test Execution Requirements

**Task-Level Test Execution:**
- After Task 2: Run `npm test wellsService.test.ts` → Verify 20 tests pass
- After Task 3: Run `npm test wellsSlice.test.ts` → Verify 20 tests pass
- After Task 4: Run `npm test WellListPage.test.tsx` → Verify 27 tests pass
- After Task 5: Run `npm test WellForm.test.tsx` → Verify 15 tests pass
- After Task 6: Run `npm test WellDetailPage.test.tsx` → Verify 31 tests pass
- After Task 7: Run `npm test WellCreatePage.test.tsx` → Verify 12 tests pass
- After Task 8: Run `npm test WellEditPage.test.tsx` → Verify 14 tests pass
- After Task 9: Run `npm test WellAutocomplete.test.tsx` → Verify 10 tests pass
- After Task 13: Run `npm run test:e2e` → Verify 21 E2E tests pass
- After Task 14: Run `npm run build` → Verify TypeScript compilation succeeds

**Story-Level Test Execution:**
- Before marking story complete:
  - Run `npm test` → Verify ALL 159 unit/integration tests pass
  - Run `npm run test:e2e` → Verify ALL 21 E2E tests pass
  - Run `npm run build` → Verify no TypeScript errors
  - Document results in Dev Agent Record with test output
  - Take screenshot or paste test results
  - **DO NOT PROCEED** to "Ready for Review" without this proof

### Total Test Count
- Service Layer: 20 tests
- RTK Query Slice: 20 tests
- Well List Page: 27 tests
- Well Form: 15 tests
- Well Detail Page: 31 tests
- Well Create Page: 12 tests
- Well Edit Page: 14 tests
- Well Autocomplete: 10 tests
- E2E Tests: 21 tests
- **Total: 180 tests**

---

## Change Log

| Date | Version | Description | Author |
|------|---------|-------------|---------|
| 2025-10-09 | 1.0 | Story created for implementation | James (Dev Agent) |
| 2025-10-09 | 1.1 | Status updated to Ready for Development | Bob (Scrum Master) |

---

## Dev Agent Record

### Agent Model Used
TBD

### Debug Log References
TBD

### Completion Notes List
TBD

### File List
TBD

---

## QA Results
(To be filled during QA review)

### QA Gate Status
Status: Pending

### Requirements Coverage
- **Total Acceptance Criteria:** 13
- **Met:** TBD
- **Coverage:** TBD

### Test Results
- **Total Tests:** TBD (Target: 180)
- **Passed:** TBD
- **Failed:** TBD
- **Execution Time:** TBD
- **Coverage:** TBD (Target: >80%)

### Code Quality Rating
TBD

### Issues Found
- **Critical:** TBD
- **High:** TBD
- **Medium:** TBD
- **Low:** TBD

### Security Review
TBD

### Performance Review
TBD

### Risk Assessment
TBD

### Gate Decision
TBD

**Full QA Report:** `docs/qa/gates/2.5-well-management-frontend-pages.yml`
